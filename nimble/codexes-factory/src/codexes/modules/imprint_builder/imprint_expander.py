import logging
import json
import hashlib
from datetime import datetime
from typing import Any, Dict, List, Optional
from functools import lru_cache

from src.codexes.core.llm_integration import LLMCaller

from src.codexes.modules.imprint_builder.imprint_concept import ImprintConcept, ImprintConceptParser

class DictWrapper(dict):
    """A simple dict wrapper to allow attribute-style access."""
    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            # Return empty string for common string fields, empty list for list fields
            if name in ['imprint_name', 'tagline', 'mission_statement', 'unique_selling_proposition', 
                       'brand_voice', 'target_audience', 'logo_concept']:
                return ''
            elif name in ['brand_values', 'primary_genres', 'visual_motifs']:
                return []
            elif name in ['color_palette', 'typography', 'automation_settings']:
                return {}
            else:
                raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
    def __setattr__(self, name, value):
        if name in self.__dict__:
            super().__setattr__(name, value)
        else:
            self[name] = value
    def __delattr__(self, name):
        try:
            del self[name]
        except KeyError:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

class ExpandedImprint:
    def __init__(self, concept: ImprintConcept, branding: DictWrapper, design_specifications: DictWrapper,
                 publishing_strategy: DictWrapper, operational_framework: DictWrapper,
                 marketing_approach: DictWrapper, financial_projections: DictWrapper,
                 expanded_at: datetime):
        self.concept = concept
        self.branding = branding
        self.design_specifications = design_specifications
        self.publishing_strategy = publishing_strategy
        self.operational_framework = operational_framework
        self.marketing_approach = marketing_approach
        self.financial_projections = financial_projections
        self.expanded_at = expanded_at
        self._distribution_data = DictWrapper({}) # Initialize as empty DictWrapper

    @property
    def distribution(self):
        # For now, distribution is not explicitly generated by ImprintExpander methods shown.
        # If it were, it would be another field like branding, etc.
        # This is a placeholder to prevent AttributeError if accessed.
        return self._distribution_data
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert ExpandedImprint to dictionary for serialization."""
        return {
            'concept': self.concept.to_dict() if hasattr(self.concept, 'to_dict') else str(self.concept),
            'branding': dict(self.branding._data) if hasattr(self.branding, '_data') else dict(self.branding),
            'design_specifications': dict(self.design_specifications._data) if hasattr(self.design_specifications, '_data') else dict(self.design_specifications),
            'publishing_strategy': dict(self.publishing_strategy._data) if hasattr(self.publishing_strategy, '_data') else dict(self.publishing_strategy),
            'operational_framework': dict(self.operational_framework._data) if hasattr(self.operational_framework, '_data') else dict(self.operational_framework),
            'marketing_approach': dict(self.marketing_approach._data) if hasattr(self.marketing_approach, '_data') else dict(self.marketing_approach),
            'financial_projections': dict(self.financial_projections._data) if hasattr(self.financial_projections, '_data') else dict(self.financial_projections),
            'expanded_at': self.expanded_at.isoformat() if self.expanded_at else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ExpandedImprint':
        """Create ExpandedImprint from dictionary."""
        from .imprint_concept import ImprintConcept
        
        # Create concept from data
        concept_data = data.get('concept', {})
        if isinstance(concept_data, str):
            # If concept is stored as string, create a basic concept
            concept = ImprintConcept(description=concept_data)
        else:
            concept = ImprintConcept.from_dict(concept_data) if hasattr(ImprintConcept, 'from_dict') else ImprintConcept(description=str(concept_data))
        
        # Create DictWrappers for each component
        branding = DictWrapper(data.get('branding', {}))
        design_specifications = DictWrapper(data.get('design_specifications', {}))
        publishing_strategy = DictWrapper(data.get('publishing_strategy', {}))
        operational_framework = DictWrapper(data.get('operational_framework', {}))
        marketing_approach = DictWrapper(data.get('marketing_approach', {}))
        financial_projections = DictWrapper(data.get('financial_projections', {}))
        
        # Parse expanded_at
        expanded_at = None
        if data.get('expanded_at'):
            try:
                expanded_at = datetime.fromisoformat(data['expanded_at'])
            except (ValueError, TypeError):
                expanded_at = datetime.now()
        else:
            expanded_at = datetime.now()
        
        return cls(
            concept=concept,
            branding=branding,
            design_specifications=design_specifications,
            publishing_strategy=publishing_strategy,
            operational_framework=operational_framework,
            marketing_approach=marketing_approach,
            financial_projections=financial_projections,
            expanded_at=expanded_at
        )

class ImprintExpander:
    """
    Expands imprint concepts into detailed, comprehensive specifications.
    """

    def __init__(self, llm_caller: LLMCaller):
        self.llm_caller = llm_caller
        self.logger = logging.getLogger(self.__class__.__name__)
        self._cache = {}  # Simple in-memory cache

    def _get_cache_key(self, prompt: str, section_name: str, temperature: float) -> str:
        """Generate cache key for LLM calls."""
        content = f"{prompt}|{section_name}|{temperature}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def _call_llm_and_parse_json(self, prompt: str, section_name: str, temperature: float = 0.7) -> DictWrapper:
        """
        Helper method to call LLM, parse JSON response, and handle errors.
        Returns a DictWrapper of the parsed JSON, or an empty DictWrapper on failure.
        Includes caching for performance.
        """
        # Check cache first
        cache_key = self._get_cache_key(prompt, section_name, temperature)
        if cache_key in self._cache:
            self.logger.info(f"Using cached result for {section_name}")
            return DictWrapper(self._cache[cache_key])
        
        try:
            response = self.llm_caller.call_model_with_prompt(prompt, temperature=temperature)
            content = response.get('content', '')
            if content:
                parsed_json = json.loads(content)
                result = DictWrapper(parsed_json)
                
                # Ensure branding has required fields
                if section_name == "branding":
                    if not result.get('imprint_name'):
                        result['imprint_name'] = "New Imprint"
                    if not result.get('mission_statement'):
                        result['mission_statement'] = "A publishing imprint dedicated to quality literature."
                    if not result.get('brand_values'):
                        result['brand_values'] = ["Quality", "Innovation", "Excellence"]
                
                # Cache the result
                self._cache[cache_key] = dict(result)
                
                self.logger.info(f"Successfully generated {section_name} content.")
                return result
            else:
                self.logger.warning(f"LLM returned empty content for {section_name}. Returning empty DictWrapper.")
                return DictWrapper({})
        except json.JSONDecodeError as e:
            self.logger.error(f"Failed to parse JSON for {section_name}: {e}. Raw content: {content[:500]}...")
            return DictWrapper({})
        except Exception as e:
            self.logger.error(f"Error generating {section_name} with LLM: {e}", exc_info=True)
            return DictWrapper({})

    def expand_concept(self, concept: ImprintConcept) -> ExpandedImprint:
        """
        Expand an imprint concept into detailed specifications.

        Args:
            concept: The imprint concept to expand

        Returns:
            Fully expanded imprint specification
        """
        self.logger.info(f"Expanding concept: {concept.name}")

        # Generate each section
        branding = self._generate_branding(concept)
        design_specs = self._generate_design_specifications(concept)
        publishing_strategy = self._generate_publishing_strategy(concept)
        operational_framework = self._generate_operational_framework(concept)
        marketing_approach = self._generate_marketing_approach(concept)
        financial_projections = self._generate_financial_projections(concept)

        expanded = ExpandedImprint(
            concept=concept,
            branding=branding,
            design_specifications=design_specs,
            publishing_strategy=publishing_strategy,
            operational_framework=operational_framework,
            marketing_approach=marketing_approach,
            financial_projections=financial_projections,
            expanded_at=datetime.now()
        )

        self.logger.info(f"Successfully expanded concept: {concept.name}")
        return expanded

    def _generate_branding(self, concept: ImprintConcept) -> DictWrapper:
        """Generate branding specifications."""
        prompt = f"""
        As an expert brand strategist for a publishing house, create comprehensive and compelling branding for an imprint based on these characteristics.
        
        Imprint Name (suggested): {concept.name if concept.name != "Default Imprint" else "New Imprint"}
        Core Description: {concept.description if concept.description else "A publishing imprint focusing on specific themes."}
        Target Audience: {concept.target_audience if concept.target_audience else "General readers."}
        Brand Personality: {concept.brand_personality if concept.brand_personality else "Professional, innovative, and reader-focused."}
        
        Provide detailed branding elements in valid JSON format only. Do not include any other conversational text or explanations.
        
        Required JSON structure:
        {{
            "imprint_name": "A refined, appealing name for the imprint",
            "mission_statement": "A concise, inspiring statement of the imprint's purpose and values",
            "brand_values": ["3-5 core values that define the imprint's ethos"],
            "brand_voice": "A description of the tone and style of communication (e.g., authoritative, witty, empathetic)",
            "tagline": "A memorable, short phrase that encapsulates the imprint's essence",
            "unique_selling_proposition": "What makes this imprint distinct and appealing to authors and readers?",
            "logo_concept": "A detailed description of the visual concept for the imprint's logo, including imagery, style, and color ideas"
        }}
        """
        return self._call_llm_and_parse_json(prompt, "branding")

    def _generate_design_specifications(self, concept: ImprintConcept) -> DictWrapper:
        """Generate design specifications."""
        prompt = f"""
        As a lead book designer, outline comprehensive design specifications for an imprint, ensuring visual consistency and appeal based on the following imprint concept:
        
        Imprint Name: {concept.name}
        Core Description: {concept.description}
        Target Audience: {concept.target_audience}
        Brand Personality: {concept.brand_personality}
        
        Provide detailed design specifications in valid JSON format only. Do not include any other conversational text or explanations.
        
        Required JSON structure:
        {{
            "color_palette": {{
                "primary": "Hex code for the main brand color",
                "secondary": "Hex code for a complementary color",
                "accent": "Hex code for a highlight color",
                "neutral": "Hex code for background/text color"
            }},
            "typography": {{
                "headline": "Recommended font styles for headlines (e.g., 'Serif, bold, elegant')",
                "body": "Recommended font styles for body text (e.g., 'Sans-serif, readable, modern')",
                "primary_font": "Primary font name for headings and titles (e.g., 'Minion Pro', 'Georgia')",
                "secondary_font": "Secondary font name for accents and captions (e.g., 'Myriad Pro', 'Helvetica')",
                "body_font": "Body text font name (e.g., 'Minion Pro', 'Times New Roman')"
            }},
            "visual_motifs": ["3-5 recurring visual elements or themes (e.g., 'Abstract patterns', 'Nature elements', 'Geometric shapes')"],
            "cover_art_direction": "A clear artistic brief for cover designers (e.g., 'Modern, minimalist, evocative photography focus')",
            "interior_layout_preferences": {{
                "chapter_start": "Specific preferences for chapter opening pages (e.g., 'Elegant drop cap, large initial letter')",
                "margins": "Standard margin sizes and page proportions (e.g., 'Standard, balanced')",
                "text_and_header_styles": "General guidance on text blocks, headers, and footers."
            }}
        }}
        """
        return self._call_llm_and_parse_json(prompt, "design specifications")

    def _generate_publishing_strategy(self, concept: ImprintConcept) -> DictWrapper:
        """Generate publishing strategy."""
        prompt = f"""
        As an experienced publishing director, craft a detailed publishing strategy for an imprint based on its core concept:
        
        Imprint Name: {concept.name}
        Core Description: {concept.description}
        Target Audience: {concept.target_audience}
        Brand Personality: {concept.brand_personality}
        
        Provide the publishing strategy in valid JSON format only. Do not include any other conversational text or explanations.
        
        Required JSON structure:
        {{
            "primary_genres": ["3-5 main genres or categories the imprint will focus on (e.g., 'Literary Fiction', 'Young Adult Fantasy')"],
            "target_readership": "A detailed demographic and psychographic description of the ideal reader",
            "publication_frequency": "How many titles per year or per season (e.g., '6-8 titles per year', '4 per season')",
            "editorial_focus": "The specific types of narratives, themes, or styles the editorial team will prioritize (e.g., 'Voice-driven narratives, strong character development')",
            "author_acquisition_strategy": "How will authors be found and signed (e.g., 'Agent submissions, literary awards, direct outreach')",
            "rights_management": ["Key rights to acquire and manage (e.g., 'World English rights', 'Translation rights (select)')"],
            "pricing_strategy": {{
                "hardcover": "General pricing tier for hardcovers (e.g., 'Premium', 'Competitive')",
                "paperback": "General pricing tier for paperbacks",
                "ebook": "General pricing tier for ebooks"
            }},
            "market_positioning": "How the imprint will differentiate itself in the market."
        }}
        """
        return self._call_llm_and_parse_json(prompt, "publishing strategy")

    def _generate_operational_framework(self, concept: ImprintConcept) -> DictWrapper:
        """Generate operational framework."""
        prompt = f"""
        As an operations manager for a modern publishing imprint, detail the operational framework, processes, and resources needed for efficient book production and business management based on:
        
        Imprint Name: {concept.name}
        Core Description: {concept.description}
        Target Audience: {concept.target_audience}
        Brand Personality: {concept.brand_personality}
        
        Provide the operational framework in valid JSON format only. Do not include any other conversational text or explanations.
        
        Required JSON structure:
        {{
            "workflow_stages": ["A sequential list of key stages from manuscript acquisition to final distribution (e.g., 'Acquisition', 'Editorial', 'Design', 'Production', 'Marketing', 'Distribution')"],
            "technology_stack": ["Essential software and systems for operations (e.g., 'Manuscript management system', 'Design software', 'ERP system')"],
            "team_structure": {{
                "editorial": "Key roles and approximate number of staff",
                "production": "Key roles and approximate number of staff",
                "marketing": "Key roles and approximate number of staff",
                "sales": "Key roles and approximate number of staff"
            }},
            "vendor_relationships": ["Types of external partners and services needed (e.g., 'Printers (POD, Offset)', 'Copyeditors', 'Proofreaders', 'Distributors')"],
            "quality_control_measures": "Key checkpoints and practices to ensure high-quality output (e.g., 'Peer review, professional proofreading, pre-press checks')",
            "communication_protocols": "How internal and external teams will communicate and collaborate."
        }}
        """
        return self._call_llm_and_parse_json(prompt, "operational framework")

    def _generate_marketing_approach(self, concept: ImprintConcept) -> DictWrapper:
        """Generate marketing approach."""
        prompt = f"""
        As a digital marketing expert specializing in publishing, outline a comprehensive marketing approach for a new imprint, leveraging its unique identity:
        
        Imprint Name: {concept.name}
        Core Description: {concept.description}
        Target Audience: {concept.target_audience}
        Brand Personality: {concept.brand_personality}
        
        Provide the marketing approach in valid JSON format only. Do not include any other conversational text or explanations.
        
        Required JSON structure:
        {{
            "target_platforms": ["Key digital and traditional platforms for marketing (e.g., 'Goodreads', 'Literary Blogs', 'Social Media (Instagram, TikTok)', 'Print Ads')"],
            "promotional_activities": ["Specific campaigns and activities (e.g., 'Author interviews', 'Book club kits', 'Giveaways', 'Review campaigns')"],
            "audience_engagement_tactics": "Strategies to build and nurture a community around the imprint (e.g., 'Online forums, newsletter, virtual events')",
            "budget_allocation": {{
                "digital_ads": "Percentage of total marketing budget (e.g., '40%')",
                "influencer_marketing": "Percentage",
                "events": "Percentage",
                "PR": "Percentage",
                "content_marketing": "Percentage"
            }},
            "brand_partnerships": ["Potential collaborations with organizations or individuals (e.g., 'Literary festivals', 'Independent bookstores', 'Educational institutions')"],
            "success_metrics": "How the effectiveness of marketing efforts will be measured."
        }}
        """
        return self._call_llm_and_parse_json(prompt, "marketing approach")

    def _generate_financial_projections(self, concept: ImprintConcept) -> DictWrapper:
        """Generate financial projections."""
        prompt = f"""
        As a financial analyst for a publishing startup, provide realistic initial financial projections for a new imprint based on its concept:
        
        Imprint Name: {concept.name}
        Core Description: {concept.description}
        Target Audience: {concept.target_audience}
        Brand Personality: {concept.brand_personality}
        
        Provide the financial projections in valid JSON format only. Do not include any other conversational text or explanations.
        
        Required JSON structure:
        {{
            "first_year_revenue_target": "Realistic revenue target for the first year (e.g., 250000)",
            "profit_margin_goal": "Target profit margin as a decimal (e.g., 0.25 for 25%)",
            "investment_required": "Estimated initial investment needed to launch and operate (e.g., 100000)",
            "funding_sources": ["Potential sources of funding (e.g., 'Angel Investors', 'Small Business Loan', 'Crowdfunding')"],
            "royalty_rates_structure": {{
                "authors": "Typical royalty percentage range for authors (e.g., '10-15%')",
                "agents": "Typical commission percentage for agents (e.g., '15%')"
            }},
            "expense_categories": ["Main categories of expenditure (e.g., 'Salaries', 'Printing', 'Marketing', 'Overhead', 'Legal')"],
            "breakeven_point_analysis": "Estimated time or sales volume to reach breakeven (e.g., 'Within 18 months', 'After selling 5000 units')",
            "long_term_financial_goals": "Strategic financial objectives for the imprint."
        }}
        """
        return self._call_llm_and_parse_json(prompt, "financial projections")