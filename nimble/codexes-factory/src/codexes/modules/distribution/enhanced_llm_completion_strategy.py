"""
Enhanced LLM Completion Strategy Module

This module provides an enhanced LLMCompletionStrategy that properly checks for
existing completions in the metadata.llm_completions dictionary and implements
a priority order for field value sources.
"""

import logging
from typing import Dict, Any, Optional, List

from ..metadata.metadata_models import CodexMetadata
from .field_mapping import MappingStrategy, MappingContext

logger = logging.getLogger(__name__)


class EnhancedLLMCompletionStrategy(MappingStrategy):
    """
    Enhanced strategy for LLM-based field completion.
    
    This strategy implements a priority order for field value sources:
    1. Direct field value in metadata
    2. Existing completion in metadata.llm_completions dictionary
    3. New completion generated by LLMFieldCompleter
    
    It also provides detailed logging for field completion source and
    handles different result formats (dictionaries, strings).
    """
    
    def __init__(self, field_completer, metadata_field: str, prompt_key: str = None, fallback_value: str = ""):
        """
        Initialize LLM completion strategy.
        
        Args:
            field_completer: Instance of LLMFieldCompleter for intelligent completion
            metadata_field: Name of the metadata field to complete
            prompt_key: Optional key of the prompt to use for completion (if different from field mapping)
            fallback_value: Value to use if LLM completion fails
        """
        self.field_completer = field_completer
        self.metadata_field = metadata_field
        self.prompt_key = prompt_key
        self.fallback_value = fallback_value
    
    def map_field(self, metadata: CodexMetadata, context: MappingContext) -> str:
        """
        Generate field value using LLM field completer with priority-based source selection.
        
        Priority order:
        1. Direct field value in metadata
        2. Existing completion in metadata.llm_completions dictionary
        3. New completion generated by LLMFieldCompleter
        
        Args:
            metadata: The source CodexMetadata object
            context: Additional context for the mapping operation
            
        Returns:
            String value for the LSI field
        """
        try:
            # Source tracking for logging
            source = "unknown"
            
            # 1. First check if we have a direct field value
            current_value = getattr(metadata, self.metadata_field, "")
            if current_value and isinstance(current_value, str) and current_value.strip():
                logger.info(f"Using existing direct value for field {self.metadata_field}: {current_value[:50]}...")
                source = "direct_field"
                return current_value
            
            # 2. Next check if we have a completion in llm_completions
            if hasattr(metadata, 'llm_completions') and metadata.llm_completions:
                # Find the appropriate prompt key for this field
                effective_prompt_key = self._determine_prompt_key(metadata)
                
                if effective_prompt_key:
                    # Try to extract value from llm_completions
                    completion_value = self._extract_completion_value(
                        metadata.llm_completions, 
                        effective_prompt_key, 
                        self.metadata_field
                    )
                    
                    if completion_value:
                        logger.info(
                            f"Using existing LLM completion for field {self.metadata_field} "
                            f"from prompt '{effective_prompt_key}'"
                        )
                        source = f"llm_completions:{effective_prompt_key}"
                        return completion_value
            
            # 3. If we get here, we need to complete the field using the LLM
            logger.info(f"No existing value found for {self.metadata_field}, generating new completion")
            completed_value = self.field_completer._complete_field(metadata, self.metadata_field)
            if completed_value:
                logger.info(f"LLM completed field {self.metadata_field}: {completed_value[:50]}...")
                source = "new_llm_completion"
                return completed_value
            else:
                logger.warning(
                    f"LLM completion failed for field {self.metadata_field}, using fallback value: "
                    f"{self.fallback_value}"
                )
                source = "fallback"
                return self.fallback_value
                
        except Exception as e:
            logger.error(f"Error in LLM completion for field {self.metadata_field}: {e}")
            return self.fallback_value
    
    def _determine_prompt_key(self, metadata: CodexMetadata) -> Optional[str]:
        """
        Determine the appropriate prompt key for a field.
        
        Args:
            metadata: The source CodexMetadata object
            
        Returns:
            Prompt key to use or None if not found
        """
        # If prompt_key is explicitly provided, use it
        if self.prompt_key and self.prompt_key in metadata.llm_completions:
            return self.prompt_key
        
        # Try to find the prompt key from the field completer's mapping
        if hasattr(self.field_completer, 'prompt_field_mapping'):
            for key, fields in self.field_completer.prompt_field_mapping.items():
                # Check if this prompt key exists in llm_completions
                if key not in metadata.llm_completions:
                    continue
                    
                # Check if this prompt maps to our field
                if isinstance(fields, str) and fields == self.metadata_field:
                    return key
                elif isinstance(fields, list) and self.metadata_field in fields:
                    return key
        
        # If we couldn't find a match through the mapping, check all keys in llm_completions
        # This handles cases where the prompt key doesn't match the field mapping
        if hasattr(metadata, 'llm_completions'):
            for key, completion in metadata.llm_completions.items():
                # Skip if completion is not a dictionary
                if not isinstance(completion, dict):
                    continue
                
                # Check if the completion contains our field directly
                if self.metadata_field in completion:
                    return key
                
                # Check if the completion contains a value field and the key contains our field name
                if "value" in completion and self.metadata_field in key:
                    return key
                
                # For extract_lsi_contributor_info type completions that contain multiple fields
                field_parts = self.metadata_field.split('_')
                for field_part in field_parts:
                    if field_part in key and len(field_part) > 3:  # Avoid matching short parts like "one"
                        return key
        
        # If we get here, we couldn't find a matching prompt key
        logger.debug(f"No matching prompt key found for field {self.metadata_field}")
        return None
    
    def _extract_completion_value(self, 
                                 llm_completions: Dict[str, Any], 
                                 prompt_key: str, 
                                 field_name: str) -> Optional[str]:
        """
        Extract a field value from LLM completions with support for different formats.
        
        Args:
            llm_completions: Dictionary of LLM completions
            prompt_key: Key of the prompt to extract from
            field_name: Name of the field to extract
            
        Returns:
            Extracted value or None if not found
        """
        try:
            # Get the completion result
            result = llm_completions.get(prompt_key)
            if not result:
                return None
            
            # Handle different result formats
            
            # Case 1: Result is a dictionary with _completion_metadata structure
            if isinstance(result, dict) and "_completion_metadata" in result:
                # Check if there's a direct "value" field
                if "value" in result:
                    return str(result["value"])
                
                # Otherwise, look for field-specific keys, removing the metadata
                filtered_result = {k: v for k, v in result.items() if k != "_completion_metadata"}
                return self._extract_from_dict(filtered_result, field_name)
            
            # Case 2: Result is a regular dictionary
            elif isinstance(result, dict):
                return self._extract_from_dict(result, field_name)
            
            # Case 3: Result is a string
            elif isinstance(result, str):
                return result
            
            # Case 4: Other types - convert to string
            else:
                return str(result)
                
        except Exception as e:
            logger.warning(f"Error extracting completion value for {field_name} from {prompt_key}: {e}")
            return None
    
    def _extract_from_dict(self, result_dict: Dict[str, Any], field_name: str) -> Optional[str]:
        """
        Extract a field value from a dictionary result with key matching.
        
        Args:
            result_dict: Dictionary to extract from
            field_name: Name of the field to extract
            
        Returns:
            Extracted value or None if not found
        """
        # Handle empty or invalid dictionaries
        if not result_dict or not isinstance(result_dict, dict):
            logger.warning(f"Invalid result dictionary for field {field_name}: {result_dict}")
            return None
            
        # Direct match
        if field_name in result_dict:
            value = result_dict[field_name]
            return str(value) if value is not None else None
        
        # Case-insensitive match
        field_name_lower = field_name.lower()
        for key, value in result_dict.items():
            if isinstance(key, str) and key.lower() == field_name_lower:
                return str(value) if value is not None else None
        
        # Partial match strategies
        
        # 1. Field name contains key or key contains field name
        for key, value in result_dict.items():
            if isinstance(key, str) and (field_name in key or key in field_name):
                return str(value) if value is not None else None
        
        # 2. Word-based matching (e.g., "contributor_bio" matches "bio")
        field_parts = field_name.split('_')
        for key, value in result_dict.items():
            if not isinstance(key, str):
                continue
                
            key_parts = key.split('_')
            # Check if any part of the field name matches any part of the key
            for field_part in field_parts:
                if field_part in key_parts:
                    return str(value) if value is not None else None
        
        # 3. If we have only one value in the dictionary, use it
        if len(result_dict) == 1:
            value = next(iter(result_dict.values()))
            return str(value) if value is not None else None
        
        # No match found
        logger.debug(f"No matching key found in dictionary for field {field_name}")
        return None