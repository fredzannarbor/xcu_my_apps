#!/usr/bin/env python3
"""
Claude Code Documentation Runner
This script should be run within Claude Code where the Task tool is available.
"""

import json
import os
from pathlib import Path

# This would be used within Claude Code where you have access to tools
def run_module_documentation_project():
    """
    Execute the module documentation project using Claude Code Task tool.

    Run this by asking Claude Code to execute this function and use the Task tool.
    """

    # Load the module inventory (generated by module_documentation_generator.py)
    inventory_file = "docs/modules/module_inventory.json"

    if not os.path.exists(inventory_file):
        print("‚ùå Module inventory not found. Run module_documentation_generator.py first")
        return

    with open(inventory_file, 'r') as f:
        modules = json.load(f)

    print(f"üìö Processing {len(modules)} modules for documentation...")

    # Process each module
    for i, module in enumerate(modules):
        module_name = module['name']
        module_path = module['relative_path']

        print(f"\nüîÑ Processing {i+1}/{len(modules)}: {module_name}")

        # Create output directory for this module
        output_dir = f"docs/modules/{module_name}"
        os.makedirs(output_dir, exist_ok=True)

        # Define the 4 documentation tasks
        tasks = {
            'api_reference': {
                'output_file': f"{output_dir}/api_reference.md",
                'prompt': f"""
Analyze the Python module at {module_path} and generate comprehensive API reference documentation.

Module info:
- Name: {module_name}
- Classes: {len(module.get('classes', []))}
- Functions: {len(module.get('functions', []))}
- Lines: {module.get('line_count', 0)}

Include:
1. Module overview and purpose
2. All classes with methods, attributes, and docstrings
3. All functions with parameters, return types, and docstrings
4. Usage examples for main functionality
5. Type hints and parameter details
6. Error handling information

Read the file first, then write comprehensive markdown documentation.
"""
            },

            'developer_guide': {
                'output_file': f"{output_dir}/developer_guide.md",
                'prompt': f"""
Create a developer guide for the Python module at {module_path}.

Module info:
- Name: {module_name}
- Classes: {len(module.get('classes', []))}
- Functions: {len(module.get('functions', []))}

Include:
1. Architecture overview and design patterns
2. How this module fits into the larger system
3. Code organization and structure
4. Development workflows and common tasks
5. Testing approach and examples
6. Known limitations, gotchas, or technical debt
7. Future improvement opportunities

Read the file and related modules, then write markdown for developers.
"""
            },

            'user_tutorial': {
                'output_file': f"{output_dir}/user_tutorial.md",
                'prompt': f"""
Write a user-friendly tutorial for the Python module at {module_path}.

Module info:
- Name: {module_name}
- Purpose: {module.get('docstring', 'Not documented')}

Include:
1. What problems this module solves
2. Step-by-step usage examples with code
3. Common use cases and scenarios
4. Troubleshooting guide for common issues
5. Best practices for effective usage
6. Real-world examples where possible

Focus on end-users, not developers. Read the code and write accessible markdown.
"""
            },

            'integration_guide': {
                'output_file': f"{output_dir}/integration_guide.md",
                'prompt': f"""
Create an integration guide for the Python module at {module_path}.

Module info:
- Name: {module_name}
- Imports: {module.get('imports', [])}

Include:
1. Dependencies and requirements
2. How to integrate with other modules/systems
3. Configuration options and environment setup
4. Common integration patterns and examples
5. Performance considerations
6. Security considerations
7. Monitoring and logging recommendations

Read the module and its dependencies, then write markdown for system integrators.
"""
            }
        }

        # This is where you'd use the Task tool in Claude Code
        # For each task, you'd call:
        # Task(
        #     description=f"Generate {doc_type} for {module_name}",
        #     prompt=task_info['prompt'],
        #     subagent_type="general-purpose"
        # )

        print(f"  üìÑ Would generate 4 documents in {output_dir}/")
        for doc_type, task_info in tasks.items():
            print(f"    - {doc_type} ‚Üí {task_info['output_file']}")

    print("\n‚úÖ Documentation generation plan complete!")
    print("üí° To execute, ask Claude Code to run this with Task tool access")

if __name__ == "__main__":
    run_module_documentation_project()